/*
  This class has been generated by the Code Generator
 */

package com.msig.masterdata;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.regex.Pattern;

import com.cordys.cpc.bsf.busobject.BSF;
import com.cordys.cpc.bsf.busobject.BusObjectConfig;
import com.cordys.cpc.bsf.busobject.BusObjectIterator;
import com.cordys.cpc.bsf.soap.SOAPRequestObject;
import com.cordys.cpc.notification.utils.LDAPUtility;
import com.cordys.notification.internal.cache.user.ContactInfo;
import com.cordys.util.Encoding;
import com.eibus.util.logger.CordysLogger;
import com.eibus.xml.nom.Document;
import com.eibus.xml.nom.Node;
import com.eibus.xml.xpath.XPath;
import com.strictparser.csv.CSVParser;
import com.strictparser.csv.CSVRecord;

public class MassUploadUtil extends MassUploadUtilBase {
	private static final String DELIM_COMMA = ",";
	private static final String DOUBLE_QUOTE = "\"";
	
	private static final Pattern NAME_PATTERN = Pattern.compile("[\\\\/:*?_;,\"'&<>|#+=]+");
	private static final Pattern EMAIL_PATTERN = Pattern.compile("^[_A-Za-z0-9-\\+]+(\\.[_A-Za-z0-9-]+)*@[A-Za-z0-9-]+(\\.[A-Za-z0-9-]+)*(\\.[A-Za-z]{2,})$");
	private static final Pattern SPACE_PATTERN = Pattern.compile("[\\s]+");

	@SuppressWarnings("unused")
	private static final CordysLogger logger = CordysLogger.getCordysLogger(MassUploadUtil.class);

	public MassUploadUtil() {
		this((BusObjectConfig) null);
	}

	public MassUploadUtil(BusObjectConfig config) {
		super(config);
	}

	private static boolean isNullOrEmpty(String obj) {
		return obj != null && obj.equals("");
	}

	private static boolean isNotValidString(String str) {
		return NAME_PATTERN.matcher(str).find();
	}

	private static boolean isValidEmail(String email) {
		return EMAIL_PATTERN.matcher(email).find();
	}

	/**
	 * Parses the given file using Strict CSV Parser and returns the read
	 * records
	 * 
	 * @param filePath
	 *            which holds the CSV file
	 * @param length
	 *            specifies the number columns in all records
	 * @param continueOnException
	 *            true - Store the exception and continues reading remaining
	 *            records false - throws Exception whenever it occurs
	 * @return
	 * @throws FileNotFoundException
	 * @throws IOException
	 */

	private static List<CSVRecord> parseCSVFileAndGetRecords(String filePath,
			int length, boolean continueOnException, boolean isStrictMode)
			throws FileNotFoundException, IOException {
		List <CSVRecord> records = null;
		FileReader reader = null;
		CSVParser parser = null;
		try {
			File fileObj = new File(filePath);
	
			reader = new FileReader(fileObj);
	
			parser = null;
		
			if (isStrictMode) {
				parser = new CSVParser(reader, ',', '"', continueOnException, false);
			} else {
				parser = new CSVParser(reader);
			}
			parser.setColumnLengthForRecord(length);
	
			records = parser.getRecords();
	
			if (parser != null) {
				parser.close();
				reader.close();
			}
			if (fileObj.exists()) {
				fileObj.delete();
			}
		} finally {
			if (reader != null) {
				reader.close();
			}
			if (parser != null) {
				parser.close();
			}
		}

		return records;
	}

	private static int massBranchUpload(String filePath, boolean isStrictMode) throws FileNotFoundException, IOException, Exception {
		List<CSVRecord> records = parseCSVFileAndGetRecords(filePath, 4, false, isStrictMode);

		StringBuffer responseBuffer = new StringBuffer();

		for (CSVRecord record : records) {
			List<String> columns = record.getColumns();

			/*
			 * If the record is invalid store the exception in buffer and
			 * continue
			 */
			if (!record.isValidRecord()) {
				responseBuffer.append(DOUBLE_QUOTE + "Record at line " + record.getLineNumber() + " is invalid. Error Message: " + record.getErrorMessage() + DOUBLE_QUOTE + "\n");
				columns.clear();
				columns = null;
				continue;
			}
			
			if (record.size() < 4) {
				responseBuffer.append(DOUBLE_QUOTE + "Record at line" + record.getLineNumber() + " contains less than 4 columns" + DOUBLE_QUOTE + "\n");
				columns.clear();
				columns = null;
				continue;
			}

			/* If the record is valid, create or update it in DB */
			String response = createOrUpdateBranch(columns.get(0), columns.get(1), columns.get(2), columns.get(3));

			if (response.equals("")) {
				columns.clear();
				columns = null;
				continue;
			}
			/*
			 * If there is any exception while persisting the record to DB,
			 * store it in buffer
			 */
			responseBuffer.append(DOUBLE_QUOTE + columns.get(0) + DOUBLE_QUOTE + DELIM_COMMA 
					+ DOUBLE_QUOTE + columns.get(1) + DOUBLE_QUOTE + DELIM_COMMA
					+ DOUBLE_QUOTE + columns.get(2) + DOUBLE_QUOTE + DELIM_COMMA 
					+ DOUBLE_QUOTE + columns.get(3) + DOUBLE_QUOTE + DELIM_COMMA  
					+ DOUBLE_QUOTE + response + DOUBLE_QUOTE + "\n");
			columns.clear();
			columns = null;
		}
		records.clear();
		records = null;

		if (responseBuffer.toString().equals("")) {
			return 0;
		}

		int rootNode = writeResponseToCSVFile(filePath, responseBuffer);

		return rootNode;
	}

	private static String createOrUpdateBranch(String application, String branchCode,
			String branchName, String description) {

		String response = "";
		if (isNullOrEmpty(application) || (!"BMS".equals(application) && !"CMS".equals(application))) {
			return "Invalid or empty application";
		}
		if (isNullOrEmpty(branchCode) || isNotValidString(branchCode)) {
			return "Branch Code cannot be empty or cannot contain any of the characters: \\ / : * ? _ ; , \" ' & < > | # + =";
		}
		if (isNullOrEmpty(branchName) /* || isNotValidString(branchName) */) {
			return "Branch Name cannot be empty or cannot contain any of the characters: \\ / : * ? _ ; , \" ' & < > | # + =";
		}
		/*if (isNullOrEmpty(servicingBranch) || isNotValidString(servicingBranch)) {
			return "Servicing Branch code cannot be empty or cannot contain any of the characters: \\ / : * ? _ ; , \" ' & < > | # + =";
		}*/
		if (SPACE_PATTERN.matcher(branchCode).find()) {
			return "Branch Code cannot contain spaces";
		}
		
		// Validation for Max Lengths
		if (application.length() > 10) {
			return "Maximum 10 characters allowed in Application";
		}
		if (branchCode.length() > 20) {
			return "Maximum 20 characters allowed in Branch Code";
		}
		if (branchName.length() > 50) {
			return "Maximum 50 characters allowed in Branch Name";
		}
		if (description.length() > 150) {
			return "Maximum 150 characters allowed in Description";
		}

		MSIG_BRANCH_MASTER branchObject = MSIG_BRANCH_MASTER.getBranchMasterObj(application, branchCode);

		try {
			if (branchObject == null) {
				// Check for duplicate branch names
				MSIG_BRANCH_MASTER branchNameobj = MSIG_BRANCH_MASTER.getMsigBranchNameRecord(application, branchName);
				if (branchNameobj != null) {
					return "Branch Name already exists";
				}

				// Create Branch record in DB
				branchObject = new MSIG_BRANCH_MASTER();
				branchObject.setAPPLICATION(application);
				branchObject.setBRANCH_CODE(branchCode);
				branchObject.setBRANCH_NAME(branchName);
				branchObject.setBRANCH_DESCRIPTION(description);

				branchObject.insert();
				branchObject.getObjectManager()._commitTransactionDirect(true);
			} else {
				// Check for Duplicate Branch Names
				MSIG_BRANCH_MASTER branchNameobj = MSIG_BRANCH_MASTER.getMsigBranchNameRecord(application, branchName);
				if (branchNameobj != null && !branchNameobj.getBRANCH_CODE().equals(branchCode)) {
					return "Branch Name already exists";
				}

				// Update Branch record in DB
				branchObject.setAPPLICATION(application);
				branchObject.setBRANCH_NAME(branchName);
				branchObject.setBRANCH_DESCRIPTION(description);
				
				branchObject.update();
				branchObject.getObjectManager()._commitTransactionDirect(true);
			}
		} catch (Exception e) {
			response = e.getMessage();
		}

		return response;
	}

	private static int massLOBUpload(String filePath, boolean isStrictMode)
			throws FileNotFoundException, IOException, Exception {
		List<CSVRecord> records = parseCSVFileAndGetRecords(filePath, 5, false, isStrictMode);

		StringBuffer responseBuffer = new StringBuffer();

		for (CSVRecord record : records) {
			List<String> columns = record.getColumns();

			/*
			 * If the record is invalid store the exception in buffer and
			 * continue
			 */
			if (!record.isValidRecord()) {
				responseBuffer.append(DOUBLE_QUOTE + "Record at line " + record.getLineNumber() + " is invalid. Error Message: " + record.getErrorMessage() + DOUBLE_QUOTE + "\n");
				columns.clear();
				columns = null;
				continue;
			}

			if (record.size() < 5) {
				responseBuffer.append(DOUBLE_QUOTE + "Record at line" + record.getLineNumber() + " contains less than 5 columns" + DOUBLE_QUOTE + "\n");
				columns.clear();
				columns = null;
				continue;
			}
			/* If the record is valid, create or update it in DB */
			String response = createOrUpdateLOB(columns.get(0), columns.get(1), columns.get(2), columns.get(3), columns.get(4));

			if (response.equals("")) {
				columns.clear();
				columns = null;
				continue;
			}

			/*
			 * If there is any exception while persisting the record to DB,
			 * store it in buffer
			 */
			responseBuffer.append(DOUBLE_QUOTE + columns.get(0) + DOUBLE_QUOTE + DELIM_COMMA 
					+ DOUBLE_QUOTE + columns.get(1) + DOUBLE_QUOTE + DELIM_COMMA
					+ DOUBLE_QUOTE + columns.get(2) + DOUBLE_QUOTE + DELIM_COMMA 
					+ DOUBLE_QUOTE + columns.get(3) + DOUBLE_QUOTE + DELIM_COMMA 
					+ DOUBLE_QUOTE + columns.get(4) + DOUBLE_QUOTE + DELIM_COMMA 
					+ DOUBLE_QUOTE + response + DOUBLE_QUOTE + "\n");
			columns.clear();
			columns = null;
		}
		records.clear();
		records = null;

		if (responseBuffer.toString().equals("")) {
			return 0;
		}

		int rootNode = writeResponseToCSVFile(filePath, responseBuffer);

		return rootNode;
	}

	private static String createOrUpdateLOB(String application, String lobCode,
			String lobName, String description, String level) {

		String response = "";

		if (isNullOrEmpty(application) || (!"BMS".equals(application) && !"CMS".equals(application))) {
			return "Invalid or empty Application";
		}
		if (isNullOrEmpty(lobCode) || isNotValidString(lobCode)) {
			return "LOB Code cannot be empty or cannot contain any of the characters: \\ / : * ? _ ; , \" ' & < > | # + =";
		}
		if (isNullOrEmpty(lobName)/* || isNotValidString(lobName) */) {
			return "LOB Name cannot be empty or cannot contain any of the characters: \\ / : * ? _ ; , \" ' & < > | # + =";
		}
		if (SPACE_PATTERN.matcher(lobCode).find()) {
			return "LOB Code cannot contain spaces";
		}
		if (isNullOrEmpty(level)) {
			return "Level cannot be empty";
		}
		if (!level.equals("OPERATIONAL") && !level.equals("UNDERWRITERS") && !level.equals("MANAGEMENT") && !level.equals("GROUPING")) {
			return "Invalid Level";
		}
		
		// Validation for Max Lengths
		if (lobCode.length() > 20) {
			return "Maximum 20 characters allowed in LOB Code";
		}
		if (lobName.length() > 50) {
			return "Maximum 50 characters allowed in LOB Name";
		}
		if (description.length() > 150) {
			return "Maximum 150 characters allowed in Description";
		}
		if (level.length() > 20) {
			return "Maximum 20 characters allowed in Level";
		}

		MSIG_LOB_MASTER lobObject = MSIG_LOB_MASTER.getLOBMasterObj(application, lobCode);
		try {
			if (lobObject == null) {
				// Check for duplicate LOB name records
				MSIG_LOB_MASTER lobNameObj = MSIG_LOB_MASTER.getMsigLOBRecordForName(application, lobName);
				if (lobNameObj != null) {
					return "LOB name already exists";
				}

				// Create LOB record in DB
				lobObject = new MSIG_LOB_MASTER();
				lobObject.setAPPLICATION(application);
				lobObject.setLOB_CODE(lobCode);
				lobObject.setLOB_NAME(lobName);
				lobObject.setLOB_DESCRIPTION(description);
				lobObject.setLOB_LEVEL(level);

				lobObject.insert();
				lobObject.getObjectManager()._commitTransactionDirect(true);
			} else {
				// Check for duplicate LOB name records
				MSIG_LOB_MASTER lobNameObj = MSIG_LOB_MASTER.getMsigLOBRecordForName(application, lobName);
				if (lobNameObj != null && !lobNameObj.getLOB_CODE().equals(lobCode)) {
					return "LOB name already exists";
				}

				// Update LOB record in DB
				lobObject.setAPPLICATION(application);
				lobObject.setLOB_NAME(lobName);
				lobObject.setLOB_DESCRIPTION(description);
				lobObject.setLOB_LEVEL(level);

				lobObject.update();
				lobObject.getObjectManager()._commitTransactionDirect(true);
			}
		} catch (Exception e) {
			response = e.getMessage();
		}

		return response;
	}

	private static int massRoleUpload(String filePath, boolean isStrictMode)
			throws FileNotFoundException, IOException, Exception {
		List<CSVRecord> records = parseCSVFileAndGetRecords(filePath, 4, false, isStrictMode);

		StringBuffer responseBuffer = new StringBuffer();

		for (CSVRecord record : records) {
			List<String> columns = record.getColumns();

			/*
			 * If the record is invalid store the exception in buffer and
			 * continue
			 */
			if (!record.isValidRecord()) {
				responseBuffer.append(DOUBLE_QUOTE + "Record at line " + record.getLineNumber() + " is invalid. Error Message: " + record.getErrorMessage() + DOUBLE_QUOTE + "\n");
				columns.clear();
				columns = null;
				continue;
			}
			
			if (record.size() < 4) {
				responseBuffer.append(DOUBLE_QUOTE + "Record at line" + record.getLineNumber() + " contains less than 4 columns" + DOUBLE_QUOTE + "\n");
				columns.clear();
				columns = null;
				continue;
			}
			/* If the record is valid, create or update it in DB */
			String response = createOrUpdateRole(columns.get(0), columns.get(1), columns.get(2), columns.get(3));

			if (response.equals("")) {
				columns.clear();
				columns = null;
				continue;
			}

			/*
			 * If there is any exception while persisting the record to DB,
			 * store it in buffer
			 */
			responseBuffer.append(DOUBLE_QUOTE + columns.get(0) + DOUBLE_QUOTE + DELIM_COMMA 
					+ DOUBLE_QUOTE + columns.get(1) + DOUBLE_QUOTE + DELIM_COMMA
					+ DOUBLE_QUOTE + columns.get(2) + DOUBLE_QUOTE + DELIM_COMMA 
					+ DOUBLE_QUOTE + columns.get(3) + DOUBLE_QUOTE + DELIM_COMMA 
					+ DOUBLE_QUOTE + response + DOUBLE_QUOTE + "\n");
			columns.clear();
			columns = null;
		}
		records.clear();
		records = null;

		if (responseBuffer.toString().equals("")) {
			return 0;
		}

		int rootNode = writeResponseToCSVFile(filePath, responseBuffer);

		return rootNode;
	}

	private static String createOrUpdateRole(String application, String roleCode,
			String roleName, String description) {

		String response = "";

		if (isNullOrEmpty(application) || (!"BMS".equals(application) && !"CMS".equals(application))) {
			return "Invalid or empty Application";
		}		
		if (isNullOrEmpty(roleCode) || isNotValidString(roleCode)) {
			return "Role Code cannot be empty or cannot contain any of the characters: \\ / : * ? _ ; , \" ' & < > | # + =";
		}
		if (isNullOrEmpty(roleName) /* || isNotValidString(roleName) */) {
			return "Role Name cannot be empty or cannot contain any of the characters: \\ / : * ? _ ; , \" ' & < > | # + =";
		}
		if (SPACE_PATTERN.matcher(roleCode).find()) {
			return "Role Code cannot contain spaces";
		}
		
		// Validation for Max Lengths
		if (roleCode.length() > 20) {
			return "Maximum 20 characters allowed in Role code";
		}
		if (roleName.length() > 50) {
			return "Maximum 50 characters allowed in Role name";
		}
		if (description.length() > 100) {
			return "Maximum 100 characters allowed in Description";
		}

		MSIG_ROLES_MASTER roleObject = MSIG_ROLES_MASTER.getRolesMasterObj(application, roleCode);
		try {
			if (roleObject == null) {
				// Check for duplicate LOB name records
				MSIG_ROLES_MASTER roleNameObj = MSIG_ROLES_MASTER.getMsigRoleRecordForName(application, roleName);
				if (roleNameObj != null) {
					return "Role name already exists";
				}

				// Create Role record in DB
				roleObject = new MSIG_ROLES_MASTER();
				roleObject.setAPPLICATION(application);
				roleObject.setROLE_CODE(roleCode);
				roleObject.setROLE_NAME(roleName);
				roleObject.setROLE_DESCRIPTION(description);

				roleObject.insert();
				roleObject.getObjectManager()._commitTransactionDirect(true);
			} else {
				// Check for duplicate LOB name records
				MSIG_ROLES_MASTER roleNameObj = MSIG_ROLES_MASTER.getMsigRoleRecordForName(application, roleName);
				if (roleNameObj != null
						&& !roleNameObj.getROLE_CODE().equals(roleCode)) {
					return "Role name already exists";
				}

				// Update Role record in DB
				roleObject.setAPPLICATION(application);
				roleObject.setROLE_NAME(roleName);
				roleObject.setROLE_DESCRIPTION(description);

				roleObject.update();
				roleObject.getObjectManager()._commitTransactionDirect(true);
			}
		} catch (Exception e) {
			response = e.getMessage();
		}

		return response;
	}

	private static int getMassUploadConfig() {
		SOAPRequestObject sro = new SOAPRequestObject("http://schemas.cordys.com/1.0/xmlstore", "GetXMLObject", new String[]{"key"}, new String[]{"/com/msig/masterdata/mass-upload-config.xml"});
		
		int response = sro.execute();
		
		return response;
	}
	
	private static int massUserUpload(String filePath, boolean isStrictMode) throws FileNotFoundException, IOException, Exception {

		MasterDataUtil.consilidatePartition();
		Thread.sleep(10000);
		
		List<CSVRecord> records = parseCSVFileAndGetRecords(filePath, 9, false, isStrictMode);
		
		StringBuffer responseBuffer = new StringBuffer();
		
		int configDataNode = getMassUploadConfig();
		String logLocation = Node.getData(XPath.getFirstMatch("descendant-or-self::MassuploadLogLocation", null, configDataNode));
		
		Date currDate = new Date();
		SimpleDateFormat sdf = new SimpleDateFormat("yyyyMMddHHmmss");
		String currTimestamp = sdf.format(currDate);
		
		File fileObj = new File(logLocation + "\\MASS_USER_UPLOAD_LOG" + currTimestamp + ".log");
		FileWriter writerObj = null;

		try {
		
			writerObj = new FileWriter(fileObj, true);
			
			for (CSVRecord record : records) {
				List<String> columns = record.getColumns();
	
				/*
				 * If the record is invalid store the exception in buffer and
				 * continue
				 */
				if (!record.isValidRecord()) {
					responseBuffer.append(DOUBLE_QUOTE + "Record at line " + record.getLineNumber() + " is invalid. Error Message: " + record.getErrorMessage() + DOUBLE_QUOTE + "\n");
					columns.clear();
					columns = null;
					continue;
				}
				
				if (record.size() < 9) {
					responseBuffer.append(DOUBLE_QUOTE + "Record at line" + record.getLineNumber() + " contains less than 9 columns" + DOUBLE_QUOTE + "\n");
					columns.clear();
					columns = null;
					continue;
				}
				/* If the record is valid, create or update it in DB */
				String response = createOrUpdateUser(columns.get(0), columns.get(1), columns.get(2), columns.get(3), columns.get(4), columns.get(5), columns.get(6), columns.get(7), columns.get(8));
				
				if (response.equals("")) {
					writerObj.write("Creation or updation of user with id " + columns.get(0) + " is successful\n");
					columns.clear();
					columns = null;
					continue;
				} else {
					writerObj.write("Creation or updation of user with id " + columns.get(0) + " is failed. The reason is:\t" + response + "\n");
				}
	
				/*
				 * If there is any exception while persisting the record to DB,
				 * store it in buffer
				 */
				responseBuffer.append(DOUBLE_QUOTE + columns.get(0) + DOUBLE_QUOTE + DELIM_COMMA 
						+ DOUBLE_QUOTE + columns.get(1) + DOUBLE_QUOTE + DELIM_COMMA
						+ DOUBLE_QUOTE + columns.get(2) + DOUBLE_QUOTE + DELIM_COMMA 
						+ DOUBLE_QUOTE + columns.get(3) + DOUBLE_QUOTE + DELIM_COMMA 
						+ DOUBLE_QUOTE + columns.get(4) + DOUBLE_QUOTE + DELIM_COMMA
						+ DOUBLE_QUOTE + columns.get(5) + DOUBLE_QUOTE + DELIM_COMMA 

						+ DOUBLE_QUOTE + columns.get(6) + DOUBLE_QUOTE + DELIM_COMMA
						+ DOUBLE_QUOTE + columns.get(7) + DOUBLE_QUOTE + DELIM_COMMA 
						+ DOUBLE_QUOTE + columns.get(8) + DOUBLE_QUOTE + DELIM_COMMA

						+ DOUBLE_QUOTE + response + DOUBLE_QUOTE + "\n");
				columns.clear();
				columns = null;
			}
			
		} finally {
			if (writerObj != null) {
				writerObj.flush();
				writerObj.close();
			}
		}
		records.clear();
		records = null;

		if (responseBuffer.toString().equals("")) {
			return 0;
		}
		
		MasterDataUtil.consilidatePartition();
		
		int rootNode = writeResponseToCSVFile(filePath, responseBuffer);

		return rootNode;
	}

private static String createOrUpdateUser(String userId, String userName, String email, String producerCode, 


			String designation, String did, String faxNo, String agentCode, String agencyName) {

		
		String response = "";
		producerCode = (producerCode.equalsIgnoreCase("pool")) ? "" : producerCode;

		if (isNullOrEmpty(userId) || isNotValidString(userId)) {
			return "User ID cannot be empty or cannot contain any of the characters: \\ / : * ? _ ; , \" ' & < > | # + =";
		}
		if (isNullOrEmpty(userName) || isNotValidString(userName)) {
			return "User Name cannot be empty or cannot contain any of the characters: \\ / : * ? _ ; , \" ' & < > | # + =";
		}
		if (isNullOrEmpty(email) || !isValidEmail(email)) {
			return "Invalid or empty email";
		}
		if (SPACE_PATTERN.matcher(userId).find()) {
			return "User ID cannot contain spaces";
		}
		
		// Validation for Max Lengths
		if (userId.length() > 20) {
			return "Maximum 20 characters allowed in User ID";
		}
		if (userName.length() > 150) {
			return "Maximum 150 characters allowed in User Full Name";
		}
		if (email.length() > 50) {
			return "Maximum 50 characters allowed in Email";
		}
		if (producerCode.length() > 10) {
			return "Maximum 10 characters allowed in Producer Code";
		}
		if (designation.length() > 100) {
			return "Maximum 100 characters allowed in Designation";
		}
		if (did.length() > 30) {
			return "Maximum 30 characters allowed in DID";
		}
		if (faxNo.length() > 40) {
			return "Maximum 40 characters allowed in Fax No";
		}
	if (agentCode.length() > 20) {
			return "Maximum 20 characters allowed in Agent Code";
		}
		if (agencyName.length() > 150) {
			return "Maximum 150 characters allowed in Agency Name";
		}

		boolean hasDuplicateProdCode = MSIG_USERS_MASTER.isProducerCodeExists(producerCode, userId);
		if (hasDuplicateProdCode) {
			return "Producer code already exists";
		}
		
		MSIG_USERS_MASTER userObject = MSIG_USERS_MASTER.getUsersMasterObj(userId);
		try {
			if (userObject == null) {
				






				// Create User record in DB
				userObject = new MSIG_USERS_MASTER();
				userObject.setUSER_ID(userId);
				userObject.setUSER_FULL_NAME(userName);
				userObject.setUSER_EMAIL(email);
				userObject.setPRODUCER_CODE(producerCode);
				userObject.setDESIGNATION(designation);
				userObject.setDID(did);
				userObject.setFAX_NO(faxNo);
				userObject.setAGENT_CODE(agentCode);
				userObject.setAGENCY_NAME(agencyName);

				userObject.insert();
				userObject.getObjectManager()._commitTransactionDirect(true);
			} else {
				







				// Update User record in DB
				userObject.setUSER_FULL_NAME(userName);
				userObject.setUSER_EMAIL(email);
				userObject.setPRODUCER_CODE(producerCode);
				userObject.setDESIGNATION(designation);
				userObject.setDID(did);
				userObject.setFAX_NO(faxNo);
				userObject.setAGENT_CODE(agentCode);
				userObject.setAGENCY_NAME(agencyName);

				userObject.update();
				userObject.getObjectManager()._commitTransactionDirect(true);
			}
		} catch (Exception e) {
			response = "Exception occured while inserting/updating user in OTDS";
		}








		return response;
	}

	private static int massBranchLOBUpload(String filePath, boolean isStrictMode)
			throws FileNotFoundException, IOException, Exception {

		List<CSVRecord> records = parseCSVFileAndGetRecords(filePath, 3, false, isStrictMode);

		StringBuffer responseBuffer = new StringBuffer();

		for (CSVRecord record : records) {
			List<String> columns = record.getColumns();

			/*
			 * If the record is invalid store the exception in buffer and
			 * continue
			 */
			if (!record.isValidRecord()) {
				responseBuffer.append(DOUBLE_QUOTE + "Record at line " + record.getLineNumber() + " is invalid. Error Message: " + record.getErrorMessage() + DOUBLE_QUOTE + "\n");
				columns.clear();
				columns = null;
				continue;
			}

			if (record.size() < 3) {
				responseBuffer.append(DOUBLE_QUOTE + "Record at line" + record.getLineNumber() + " contains less than 3 columns" + DOUBLE_QUOTE + "\n");
				columns.clear();
				columns = null;
				continue;
			}
			/* If the record is valid, create or update it in DB */
			String response = createOrUpdateBranchLOB(columns.get(0), columns.get(1), columns.get(2));

			if (response.equals("")) {
				columns.clear();
				columns = null;
				continue;
			}

			/*
			 * If there is any exception while persisting the record to DB,
			 * store it in buffer
			 */
			responseBuffer.append(DOUBLE_QUOTE + columns.get(0) + DOUBLE_QUOTE + DELIM_COMMA 
					+ DOUBLE_QUOTE + columns.get(1) + DOUBLE_QUOTE + DELIM_COMMA
					+ DOUBLE_QUOTE + columns.get(2) + DOUBLE_QUOTE + DELIM_COMMA
					+ DOUBLE_QUOTE + response + DOUBLE_QUOTE + "\n");
			columns.clear();
			columns = null;
		}
		records.clear();
		records = null;

		if (responseBuffer.toString().equals("")) {
			return 0;
		}

		int rootNode = writeResponseToCSVFile(filePath, responseBuffer);

		return rootNode;
	}

	private static String createOrUpdateBranchLOB(String application, String branchCode, String lobCode) {

		String response = "";
		
		if (isNullOrEmpty(application) || (!"BMS".equals(application) && !"CMS".equals(application))) {
			return "Invalid or empty Application";
		}
		String validateResponse = validateFields(branchCode, lobCode, null, null);
		if (!validateResponse.equals("")) {
			return validateResponse;
		}

		MSIG_BRANCH_MASTER branchObject = MSIG_BRANCH_MASTER.getBranchMasterObj(application, branchCode);
		if (branchObject == null) {
			return "Branch Code doesn't exist in Branch Master";
		}

		MSIG_LOB_MASTER lobObject = MSIG_LOB_MASTER.getLOBMasterObj(application, lobCode);
		if (lobObject == null) {
			return "LOB Code doesn't exist in LOB Master";
		}
		
		// Check for Max Length
		if (branchCode.length() > 20) {
			return "Maximum 20 characters allowed in Branch code";
		}
		if (lobCode.length() > 20) {
			return "Maximum 20 characters allowed in LOB code";
		}

		MSIG_BRANCH_LOB_MAPPING branchLOBObject = MSIG_BRANCH_LOB_MAPPING.getMsigBranchLobMappingObject(application, branchCode, lobCode);
		try {
			if (branchLOBObject == null) {
				// Create Mapping record in DB
				branchLOBObject = new MSIG_BRANCH_LOB_MAPPING();
				branchLOBObject.setAPPLICATION(application);
				branchLOBObject.setBRANCH_CODE(branchCode);
				branchLOBObject.setLOB_CODE(lobCode);

				branchLOBObject.insert();
				branchLOBObject.getObjectManager()._commitTransactionDirect(true);
			} else {
				// No need to map again
				return "Mapping already exists";
			}
		} catch (Exception e) {
			response = e.getMessage();
		}

		return response;
	}

	private static int massBranchLOBRoleUpload(String filePath, boolean isStrictMode) throws FileNotFoundException, IOException,
			Exception {

		List<CSVRecord> records = parseCSVFileAndGetRecords(filePath, 4, false, isStrictMode);

		StringBuffer responseBuffer = new StringBuffer();

		for (CSVRecord record : records) {
			List<String> columns = record.getColumns();

			/*
			 * If the record is invalid store the exception in buffer and
			 * continue
			 */
			if (!record.isValidRecord()) {
				responseBuffer.append(DOUBLE_QUOTE + "Record at line " + record.getLineNumber() + " is invalid. Error Message: " + record.getErrorMessage() + DOUBLE_QUOTE + "\n");
				
				columns.clear();
				columns = null;
				continue;
			}
			
			if (record.size() < 4) {
				responseBuffer.append(DOUBLE_QUOTE + "Record at line" + record.getLineNumber() + " contains less than 4 columns" + DOUBLE_QUOTE + "\n");
				
				columns.clear();
				columns = null;
				continue;
			}
			/* If the record is valid, create or update it in DB */
			String response = createOrUpdateBranchLOBRole(columns.get(0), columns.get(1), columns.get(2), columns.get(3));

			if (response.equals("")) {
				columns.clear();
				columns = null;
				continue;
			}

			/*
			 * If there is any exception while persisting the record to DB,
			 * store it in buffer
			 */
			responseBuffer.append(DOUBLE_QUOTE + columns.get(0) + DOUBLE_QUOTE + DELIM_COMMA 
					+ DOUBLE_QUOTE + columns.get(1) + DOUBLE_QUOTE + DELIM_COMMA
					+ DOUBLE_QUOTE + columns.get(2) + DOUBLE_QUOTE + DELIM_COMMA 
					+ DOUBLE_QUOTE + columns.get(3) + DOUBLE_QUOTE + DELIM_COMMA 
					+ DOUBLE_QUOTE + response + DOUBLE_QUOTE + "\n");
			
			columns.clear();
			columns = null;
		}
		records.clear();
		records = null;

		if (responseBuffer.toString().equals("")) {
			return 0;
		}

		int rootNode = writeResponseToCSVFile(filePath, responseBuffer);

		return rootNode;
	}

	private static String createOrUpdateBranchLOBRole(String application, String branchCode, String lobCode, String roleCode) {

		String response = "";

		if (isNullOrEmpty(application) || (!"BMS".equals(application) && !"CMS".equals(application))) {
			return "Invalid or empty Application";
		}
		
		String validateResponse = validateFields(branchCode, lobCode, roleCode, null);
		if (!validateResponse.equals("")) {
			return validateResponse;
		}

		MSIG_BRANCH_MASTER branchObject = MSIG_BRANCH_MASTER.getBranchMasterObj(application, branchCode);
		if (branchObject == null) {
			return "Branch Code doesn't exist in Branch Master";
		}

		MSIG_LOB_MASTER lobObject = MSIG_LOB_MASTER.getLOBMasterObj(application, lobCode);
		if (lobObject == null) {
			return "LOB Code doesn't exist in LOB Master";
		}

		MSIG_ROLES_MASTER roleObject = MSIG_ROLES_MASTER.getRolesMasterObj(application, roleCode);
		if (roleObject == null) {
			return "Role Code doesn't exist in Roles Master";
		}

		MSIG_BRANCH_LOB_MAPPING branchLOBObject = MSIG_BRANCH_LOB_MAPPING.getMsigBranchLobMappingObject(application, branchCode, lobCode);
		if (branchLOBObject == null) {
			String lobMappingResp = createOrUpdateBranchLOB(application, branchCode, lobCode);
			if (!lobMappingResp.equals("")) {
				return lobMappingResp;				
			}
		}

		branchObject = null;
		lobObject = null;
		roleObject = null;
		branchLOBObject = null;

		// Check for Max Length
		if (application.length() > 10) {
			return "Maximum 10 characters allowed in Application";
		}
		if (branchCode.length() > 20) {
			return "Maximum 20 characters allowed in Branch code";
		}
		if (lobCode.length() > 20) {
			return "Maximum 20 characters allowed in LOB code";
		}
		if (roleCode.length() > 20) {
			return "Maximum 20 characters allowed in Role Code";
		}
		
		MSIG_BRANCH_LOB_ROLE_MAPPING branchLOBRoleObject = MSIG_BRANCH_LOB_ROLE_MAPPING.getMsigBranchLobRoleMappingObject(application, branchCode, lobCode, roleCode);
		try {
			if (branchLOBRoleObject == null) {
				// Create Mapping record in DB
				branchLOBRoleObject = new MSIG_BRANCH_LOB_ROLE_MAPPING();
				branchLOBRoleObject.setAPPLICATION(application);
				branchLOBRoleObject.setBRANCH_CODE(branchCode);
				branchLOBRoleObject.setLOB_CODE(lobCode);
				branchLOBRoleObject.setROLE_CODE(roleCode);

				branchLOBRoleObject.insert();
				branchLOBRoleObject.getObjectManager()
						._commitTransactionDirect(true);
				branchLOBRoleObject = null;
			} else {
				// No need to map again
				return "Mapping already exists";
			}
		} catch (Exception e) {
			response = "Exception occured while updating the role to user mapping";
		}

		return response;
	}

	private static int massBranchLOBRoleUserUpload(String filePath, boolean isStrictMode) throws FileNotFoundException, IOException, Exception {

		MasterDataUtil.consilidatePartition();
		Thread.sleep(10000);
		
		List<CSVRecord> records = parseCSVFileAndGetRecords(filePath, 5, false, isStrictMode);

		StringBuffer responseBuffer = new StringBuffer();

		for (CSVRecord record : records) {
			List<String> columns = record.getColumns();

			/*
			 * If the record is invalid store the exception in buffer and
			 * continue
			 */
			if (!record.isValidRecord()) {
				responseBuffer.append(DOUBLE_QUOTE + "Record at line " + record.getLineNumber() + " is invalid. Error Message: " + record.getErrorMessage() + DOUBLE_QUOTE + "\n");
				
				columns.clear();
				columns = null;
				continue;
			}
			
			if (record.size() < 5) {
				responseBuffer.append(DOUBLE_QUOTE + "Record at line" + record.getLineNumber() + " contains less than 5 columns" + DOUBLE_QUOTE + "\n");
				
				columns.clear();
				columns = null;
				continue;
			}
			/* If the record is valid, create or update it in DB */
			String response = createOrUpdateBranchLOBRoleUser(columns.get(0), columns.get(1), columns.get(2), columns.get(3), columns.get(4));

			if (response.equals("")) {
				columns.clear();
				columns = null;
				continue;
			}

			/*
			 * If there is any exception while persisting the record to DB,
			 * store it in buffer
			 */
			responseBuffer.append(DOUBLE_QUOTE + columns.get(0) + DOUBLE_QUOTE + DELIM_COMMA 
					+ DOUBLE_QUOTE + columns.get(1) + DOUBLE_QUOTE + DELIM_COMMA
					+ DOUBLE_QUOTE + columns.get(2) + DOUBLE_QUOTE + DELIM_COMMA 
					+ DOUBLE_QUOTE + columns.get(3) + DOUBLE_QUOTE + DELIM_COMMA
					+ DOUBLE_QUOTE + columns.get(4) + DOUBLE_QUOTE + DELIM_COMMA
					+ DOUBLE_QUOTE + response + DOUBLE_QUOTE + "\n");
			
			columns.clear();
			columns = null;
		}
		
		records.clear();
		records = null;

		if (responseBuffer.toString().equals("")) {
			return 0;
		}
		
		MasterDataUtil.consilidatePartition();
		
		int rootNode = writeResponseToCSVFile(filePath, responseBuffer);

		return rootNode;
	}

	private static int massBranchLOBRoleUserUploadNew(String filePath, boolean isStrictMode) throws Exception {

		MasterDataUtil.consilidatePartition();
		Thread.sleep(10000);
		
		List<CSVRecord> records = parseCSVFileAndGetRecords(filePath, 14, false, isStrictMode);

		StringBuffer responseBuffer = new StringBuffer();

		BusObjectIterator<MSIG_LOB_MASTER> lobIter = null;
		
		for (int index = 0; index < records.size(); index++) {

			CSVRecord record = records.get(index);
			List<String> columns = record.getColumns();

			lobIter = MSIG_LOB_MASTER.getMsigLobMasterObjects(columns.get(0), columns.get(0), "0", "zzzzzz");
			
			/*
			 * If the record is invalid store the exception in buffer and
			 * continue
			 */
			if (!record.isValidRecord()) {
				responseBuffer.append(DOUBLE_QUOTE + "Record at line " + record.getLineNumber() + " is invalid. Error Message: " + record.getErrorMessage() + DOUBLE_QUOTE + "\n");
				columns.clear();
				columns = null;
				continue;
			}
			
			if (record.size() < 14) {
				responseBuffer.append(DOUBLE_QUOTE + "Record at line" + record.getLineNumber() + " contains less than14 columns" + DOUBLE_QUOTE + "\n");
				columns.clear();
				columns = null;
				continue;
			}
			
			String response = createBLRUMapping(columns, lobIter);
			
			if (response.equals("")) {
				columns.clear();
				columns = null;
				continue;
			}

			/*
			 * If there is any exception while persisting the record to DB,
			 * store it in buffer
			 */
			responseBuffer.append(DOUBLE_QUOTE + columns.get(0) + DOUBLE_QUOTE + DELIM_COMMA 
					+ DOUBLE_QUOTE + columns.get(1) + DOUBLE_QUOTE + DELIM_COMMA
					+ DOUBLE_QUOTE + columns.get(2) + DOUBLE_QUOTE + DELIM_COMMA 
					+ DOUBLE_QUOTE + columns.get(3) + DOUBLE_QUOTE + DELIM_COMMA
					+ DOUBLE_QUOTE + columns.get(4) + DOUBLE_QUOTE + DELIM_COMMA
					+ DOUBLE_QUOTE + response + DOUBLE_QUOTE + "\n");
			
			columns.clear();
			columns = null;
			record = null;
		}
		
		records.clear();
		records = null;

		if (responseBuffer.toString().equals("")) {
			return 0;
		}
		
		MasterDataUtil.consilidatePartition();
		
		int rootNode = writeResponseToCSVFile(filePath, responseBuffer);

		return rootNode;
	}
	
	private static String createBLRUMapping(List<String> columns, BusObjectIterator<MSIG_LOB_MASTER> lobList) {
		String response = "";
		
		String application = columns.get(0);
		String branchCode = columns.get(1);
		String lobCode = columns.get(3);
		String roleCode = columns.get(5);
		String userId = columns.get(7);
		
		if (isNullOrEmpty(application) || (!"BMS".equals(application) && !"CMS".equals(application))) {
			return "Invalid or empty Application";
		}
		
		String validateResponse = validateFields(branchCode, lobCode, roleCode, userId);
		if (!validateResponse.equals("")) {
			return validateResponse;
		}

		// Check for Max Length
		if (application.length() > 10) {
			return "Maximum 10 characters allowed in Application";
		}
		if (branchCode.length() > 20) {
			return "Maximum 20 characters allowed in Branch code";
		}
		if (columns.get(2).length() > 50) {
			return "Maximum 50 characters allowed in Branch name";
		}
		if (lobCode.length() > 20) {
			return "Maximum 20 characters allowed in LOB code";
		}
		if (columns.get(4).length() > 50) {
			return "Maximum 50 characters allowed in LOB name";
		}
		if (roleCode.length() > 20) {
			return "Maximum 20 characters allowed in Role Code";
		}
		if (columns.get(6).length() > 50) {
			return "Maximum 50 characters allowed in Role name";
		}
		if (userId.length() > 20) {
			return "Maximum 20 characters allowed in User ID";
		}
		if (columns.get(8).length() > 150) {
			return "Maximum 150 characters allowed in User Full Name";
		}
		if (columns.get(9).length() > 50) {
			return "Maximum 50 characters allowed in Email";
		}
		if (columns.get(10).length() > 10) {
			return "Maximum 10 characters allowed in Producer Code";
		}
		if (columns.get(11).length() > 100) {
			return "Maximum 100 characters allowed in Designation";
		}
		if (columns.get(12).length() > 30) {
			return "Maximum 30 characters allowed in DID";
		}
		if (columns.get(13).length() > 40) {
			return "Maximum 40 characters allowed in Fax No";
		}
		
		MSIG_BRANCH_MASTER branchObject = MSIG_BRANCH_MASTER.getBranchMasterObj(application, branchCode);
		if (branchObject == null) {
			//return "Branch Code doesn't exist in Branch Master";
			// Create Branch
			response = createOrUpdateBranch(application, branchCode, columns.get(2), columns.get(2));
			if (!"".equals(response)) {
				return response;
			}
		}
		branchObject = null;

		MSIG_LOB_MASTER lobObject = MSIG_LOB_MASTER.getLOBMasterObj(application, lobCode);
		if (lobObject == null) {
			//return "LOB Code doesn't exist in LOB Master";
			if (!lobCode.equalsIgnoreCase("all")) {
				// Create LOB
				response = createOrUpdateLOB(application, lobCode, columns.get(4), columns.get(4), "OPERATIONAL");
				if (!"".equals(response)) {
					return response;
				}
			}
		}
		lobObject = null;

		MSIG_ROLES_MASTER roleObject = MSIG_ROLES_MASTER.getRolesMasterObj(application, roleCode);
		if (roleObject == null) {
			//return "Role Code doesn't exist in Roles Master";
			// Create Role
			if (columns.get(5).contains("Policy") && roleCode.contains("1_")) {
				roleCode = "PPJ";
			}
			response = createOrUpdateRole(application, roleCode, columns.get(6), columns.get(6));
			if (!"".equals(response)) {
				return response;
			}
		}
		roleObject = null;

		MSIG_USERS_MASTER userObject = MSIG_USERS_MASTER.getUsersMasterObj(userId);
		if (userObject == null) {
			//return "User ID doesn't exist in Users Master";
			// Create User
			response = createOrUpdateUser(userId, columns.get(8), columns.get(9), columns.get(10), columns.get(11), columns.get(12), columns.get(13), columns.get(14), columns.get(15));
			if (!"".equals(response)) {
				return response;
			}
		}
		userObject = null;

		while (lobList.hasMoreElements()) {
			
			MSIG_LOB_MASTER lobObj = lobList.nextElement();
			
			MSIG_BRANCH_LOB_MAPPING branchLOBObject = MSIG_BRANCH_LOB_MAPPING.getMsigBranchLobMappingObject(application, branchCode, lobObj.getLOB_CODE());
			if (branchLOBObject == null) {
				String lobMappingResp = createOrUpdateBranchLOB(application, branchCode, lobObj.getLOB_CODE());
				if (!lobMappingResp.equals("")) {
					return lobMappingResp;				
				}
			}
			branchLOBObject = null;
			
			// User creation
			MSIG_BRANCH_LOB_ROLE_MAPPING branchLOBRoleObject = MSIG_BRANCH_LOB_ROLE_MAPPING.getMsigBranchLobRoleMappingObject(application, branchCode, lobObj.getLOB_CODE(), roleCode);
			if (branchLOBRoleObject == null) {
				String roleMappingResp = createOrUpdateBranchLOBRole(application, branchCode, lobObj.getLOB_CODE(), roleCode);
				if (!roleMappingResp.equals("")) {
					return roleMappingResp;				
				}
			}
			branchLOBRoleObject = null;
			
			MSIG_BRANCH_LOB_ROLE_USER_MAPPING branchLOBRoleUserObject = MSIG_BRANCH_LOB_ROLE_USER_MAPPING.getMsigBranchLobRoleUserMappingObject(application, branchCode, lobObj.getLOB_CODE(), roleCode, userId);
			int roleNode = 0;
			try {
				if (branchLOBRoleUserObject == null) {
					// Create Mapping record in DB
					branchLOBRoleUserObject = new MSIG_BRANCH_LOB_ROLE_USER_MAPPING();
					branchLOBRoleUserObject.setAPPLICATION(application);
					branchLOBRoleUserObject.setBRANCH_CODE(branchCode);
					branchLOBRoleUserObject.setLOB_CODE(lobObj.getLOB_CODE());
					branchLOBRoleUserObject.setROLE_CODE(roleCode);
					branchLOBRoleUserObject.setUSER_ID(userId);

					branchLOBRoleUserObject.insert();
					branchLOBRoleUserObject.getObjectManager()._commitTransactionDirect(true);
				} else {
					// No need to map again
					response = "Mapping already exists";
				}

				roleCode = (branchCode + "_" + lobObj.getLOB_CODE() + "_" + roleCode);

				// Create Role if necessary and assign user to the role
				MasterDataUtil.createRoleAndAssignUserInLDAP(roleCode, userId);

			} catch (Exception e) {
				response = "Exception occured while assigning role to user";
			} finally {
				if (Node.isValidNode(roleNode)) {
					Node.delete(roleNode);
					roleNode = 0;
				}
			}
			
			
			lobObj = null;
		}

		return response;
	}
	
	private static String createOrUpdateBranchLOBRoleUser(String application, String branchCode, String lobCode, String roleCode, String userId) {

		String response = "";

		if (isNullOrEmpty(application) || (!"BMS".equals(application) && !"CMS".equals(application))) {
			return "Invalid or empty Application";
		}
		
		String validateResponse = validateFields(branchCode, lobCode, roleCode, userId);
		if (!validateResponse.equals("")) {
			return validateResponse;
		}

		MSIG_BRANCH_MASTER branchObject = MSIG_BRANCH_MASTER.getBranchMasterObj(application, branchCode);
		if (branchObject == null) {
			return "Branch Code doesn't exist in Branch Master";
		}
		branchObject = null;

		MSIG_LOB_MASTER lobObject = MSIG_LOB_MASTER.getLOBMasterObj(application, lobCode);
		if (lobObject == null) {
			return "LOB Code doesn't exist in LOB Master";
		}
		lobObject = null;

		MSIG_ROLES_MASTER roleObject = MSIG_ROLES_MASTER.getRolesMasterObj(application, roleCode);
		if (roleObject == null) {
			return "Role Code doesn't exist in Roles Master";
		}
		roleObject = null;

		MSIG_USERS_MASTER userObject = MSIG_USERS_MASTER.getUsersMasterObj(userId);
		if (userObject == null) {
			return "User ID doesn't exist in Users Master";
		}
		userObject = null;

		MSIG_BRANCH_LOB_MAPPING branchLOBObject = MSIG_BRANCH_LOB_MAPPING.getMsigBranchLobMappingObject(application, branchCode, lobCode);
		if (branchLOBObject == null) {
			String lobMappingResp = createOrUpdateBranchLOB(application, branchCode, lobCode);
			if (!lobMappingResp.equals("")) {
				return lobMappingResp;				
			}
		}
		branchLOBObject = null;

		MSIG_BRANCH_LOB_ROLE_MAPPING branchLOBRoleObject = MSIG_BRANCH_LOB_ROLE_MAPPING.getMsigBranchLobRoleMappingObject(application, branchCode, lobCode, roleCode);
		if (branchLOBRoleObject == null) {
			String roleMappingResp = createOrUpdateBranchLOBRole(application, branchCode, lobCode, roleCode);
			if (!roleMappingResp.equals("")) {
				return roleMappingResp;				
			}
		}
		branchLOBRoleObject = null;

		// Check for Max Length
		if (application.length() > 10) {
			return "Maximum 10 characters allowed in Application";
		}
		if (branchCode.length() > 20) {
			return "Maximum 20 characters allowed in Branch code";
		}
		if (lobCode.length() > 20) {
			return "Maximum 20 characters allowed in LOB code";
		}
		if (roleCode.length() > 20) {
			return "Maximum 20 characters allowed in Role Code";
		}
		if (userId.length() > 20) {
			return "Maximum 20 characters allowed in User ID";
		}
		
		MSIG_BRANCH_LOB_ROLE_USER_MAPPING branchLOBRoleUserObject = MSIG_BRANCH_LOB_ROLE_USER_MAPPING.getMsigBranchLobRoleUserMappingObject(application, branchCode, lobCode, roleCode, userId);
		int roleNode = 0;
		try {
			if (branchLOBRoleUserObject == null) {
				// Create Mapping record in DB
				branchLOBRoleUserObject = new MSIG_BRANCH_LOB_ROLE_USER_MAPPING();
				branchLOBRoleUserObject.setAPPLICATION(application);
				branchLOBRoleUserObject.setBRANCH_CODE(branchCode);
				branchLOBRoleUserObject.setLOB_CODE(lobCode);
				branchLOBRoleUserObject.setROLE_CODE(roleCode);
				branchLOBRoleUserObject.setUSER_ID(userId);

				branchLOBRoleUserObject.insert();
				branchLOBRoleUserObject.getObjectManager()._commitTransactionDirect(true);
			} else {
				// No need to map again
				//response = "Mapping already exists";
				response = "";
			}

			roleCode = (branchCode + "_" + lobCode + "_" + roleCode);

			// Create Role if necessary and assign user to the role
			MasterDataUtil.createRoleAndAssignUserInLDAP(roleCode, userId);

		} catch (Exception e) {
			response = "Exception occured while inserting or updating the record";
		} finally {
			if (Node.isValidNode(roleNode)) {
				Node.delete(roleNode);
				roleNode = 0;
			}
		}

		return response;
	}

	private static String validateFields(String branchCode, String lobCode, String roleCode, String userId) {
		if (branchCode != null) {
			if (isNullOrEmpty(branchCode) || isNotValidString(branchCode)) {
				return "Branch Code cannot be empty or cannot contain any of the characters: \\ / : * ? _ ; , \" ' & < > | # + =";
			}
		}
		if (lobCode != null) {
			if (isNullOrEmpty(lobCode) || isNotValidString(lobCode)) {
				return "LOB Code cannot be empty or cannot contain any of the characters: \\ / : * ? _ ; , \" ' & < > | # + =";
			}
		}
		if (roleCode != null) {
			if (isNullOrEmpty(roleCode) || isNotValidString(roleCode)) {
				return "Role Code cannot be empty or cannot contain any of the characters: \\ / : * ? _ ; , \" ' & < > | # + =";
			}
		}
		if (userId != null) {
			if (isNullOrEmpty(userId) || isNotValidString(userId)) {
				return "User ID cannot be empty or cannot contain any of the characters: \\ / : * ? _ ; , \" ' & < > | # + =";
			}
		}
		return "";
	}

	public static int writeResponseToCSVFile(String filePath, StringBuffer responseBuffer) throws Exception {

		byte[] response = responseBuffer.toString().getBytes();

		// Get the Base64 content of the file
		String base64Content = new String(
				(byte[]) Encoding.BASE64_ENCODING.encode(response));

		Document doc = BSF.getXMLDocument();
		int rootNode = 0;

		try {
			rootNode = doc.createElement("RESPONSE");
			Node.createTextElement("BASE64_CONTENT", base64Content, rootNode);
			return Node.clone(rootNode, true);
		} finally {
			if (Node.isValidNode(rootNode)) {
				Node.delete(rootNode);
				rootNode = 0;
			}
		}

	}

	public static int callMassUploadMethod(String filePath, String fileType, boolean isStrictMode) throws Exception {
		int response = 0;

		switch (fileType) {

		case "Branch":
			response = massBranchUpload(filePath, false);
			break;
		case "LOB":
			response = massLOBUpload(filePath, false);
			break;
		case "Role":
			response = massRoleUpload(filePath, false);
			break;
		case "User":
			response = massUserUpload(filePath, false);
			break;
		case "Branch_LOB":
			response = massBranchLOBUpload(filePath, false);
			break;
		case "Branch_LOB_Role":
			response = massBranchLOBRoleUpload(filePath, false);
			break;
		case "Branch_LOB_Role_User":
			response = massBranchLOBRoleUserUpload(filePath, false);
			break;
		case "Branch_LOB_Role_User_New":
			response = massBranchLOBRoleUserUploadNew(filePath, false);
			break;
		default:
			throw new Exception("Invalid File Type");

		}
		return response;
	}

	public static String sendStatusMail(String subject, String emailBody,
			String attachmentName, String attachmentContent, String roleCode,
			String senderEmailID, String senderDisplayName) throws Exception {

		if (roleCode == null) {
			throw new Exception("Role Code cannot be empty");
		}
		if (roleCode.equals("")) {
			throw new Exception("Role Code cannot be empty");
		}

		String organizationDN = BSF.getOrganization();
		String roleDN = "cn=" + roleCode + ",cn=organizational roles," + organizationDN;
		
		ArrayList<String> usersList = (ArrayList<String>) LDAPUtility .getAllUsersForRole(roleDN, organizationDN);

		// Get all user email addresses from Role.
		HashMap<String, String> emailAddrList = new HashMap<>();
		HashSet<String> emails = new HashSet<>();

		int response = 0;
		
		for (String user : usersList) {
			ContactInfo cInfo = LDAPUtility.getUserContactInfo(user);
			String eAddr = cInfo.getEmailAddress();
			String name = cInfo.getDisplayName();

			try {
				SOAPRequestObject sro = new SOAPRequestObject(
						"http://schemas.cordys.com/notification/workflow/1.0",
						"GetUserInboxPreferences", new String[] { "UserDN" },
						new String[] { user });
		
				response = sro.execute();
		
				String defaultDelivery = Node.getData(XPath.getFirstMatch("descendant-or-self::DEFAULT_DELIVERY", null, response));
		
				if (!defaultDelivery.equals("BOTH")) {
					continue;
				}
		
				if (emails.contains(eAddr)) {
					continue;
				} else {
					emails.add(eAddr);
				}
				
				if (!eAddr.equals("")) {
					emailAddrList.put(eAddr, name);
				}
			} finally {
				if (Node.isValidNode(response)) {
					Node.delete(response);
					response = 0;
				}
			}
		}

		if (emails.isEmpty()) {
			return "No emails for the users";
		}

		SOAPRequestObject sendMailSRO = new SOAPRequestObject(
				"http://schemas.cordys.com/1.0/email", "SendMail",
				new String[] { "subject" }, new String[] { subject });

		Document doc = BSF.getXMLDocument();

		StringBuffer mailContent = new StringBuffer();
		mailContent.append("Dear Admin,<br/><br/>");
		mailContent.append(emailBody + "<br/><br/><br/>");
		mailContent.append("Thanks,<br/>MSIG Team<br/>");

		int toNode = 0;
		int bodyNode = 0;
		int fromNode = 0;
		int attachmentsNode = 0;
		int attachmentNode = 0;

		try {
			// Apppend all 'to' addresses
			toNode = doc.createElement("to");
			int addressNode = 0;
			for (String key : emailAddrList.keySet()) {
				addressNode = Node.createElement("address", toNode);
				Node.createTextElement("emailAddress", key, addressNode);
				Node.createTextElement("displayName", emailAddrList.get(key).toString(), addressNode);
			}
			emailAddrList.clear();
			emailAddrList = null;
			
			sendMailSRO.addParameterAsXml(toNode);

			// Append body node
			bodyNode = doc.createCDataElement("body", mailContent.toString());
			Node.setAttribute(bodyNode, "type", "html");
			sendMailSRO.addParameterAsXml(bodyNode);

			if (!attachmentContent.equals("") && !attachmentName.equals("")) {
				// Append attachment node
				attachmentsNode = doc.parseString("<attachments></attachments>");
				attachmentNode = Node.createCDataElement("attachment", attachmentContent, attachmentsNode);
				Node.setAttribute(attachmentNode, "name", attachmentName);
				Node.setAttribute(attachmentNode, "encoded", "true");
				sendMailSRO.addParameterAsXml(attachmentsNode);
			}
			// Append 'from' node
			fromNode = doc.createElement("from");
			addressNode = Node.createElement("address", fromNode);
			Node.createTextElement("emailAddress", senderEmailID, addressNode);
			Node.createTextElement("displayName", senderDisplayName, addressNode);
			
			sendMailSRO.addParameterAsXml(fromNode);
			// Admin Dn
			sendMailSRO.setUser("cn=cordysadmin,cn=organizational users," + organizationDN);
			
			response = sendMailSRO.execute();
		} finally {
			if (Node.isValidNode(attachmentNode)) {
				Node.delete(attachmentNode);
				attachmentNode = 0;
			}
			if (Node.isValidNode(attachmentsNode)) {
				Node.delete(attachmentsNode);
				attachmentsNode = 0;
			}
			if (Node.isValidNode(fromNode)) {
				Node.delete(fromNode);
				fromNode = 0;
			}
			if (Node.isValidNode(bodyNode)) {
				Node.delete(bodyNode);
				bodyNode = 0;
			}
			if (Node.isValidNode(toNode)) {
				Node.delete(toNode);
				toNode = 0;
			}
			if (Node.isValidNode(response)) {
				Node.delete(response);
				response = 0;
			}
			doc = null;
		}
		return emails.toString();
	}

	@Override
	public void onDelete() {
		
	}

	@Override
	public void onInsert() {
		
	}

	@Override
	public void onUpdate() {
		
	}
}
